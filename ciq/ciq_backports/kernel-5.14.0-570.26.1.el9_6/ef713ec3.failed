mm: drop is_huge_zero_pud()

jira LE-3557
Rebuild_History Non-Buildable kernel-5.14.0-570.26.1.el9_6
commit-author Peter Xu <peterx@redhat.com>
commit ef713ec3a566d3e5e011c5d6201eb661ebf94c1f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-570.26.1.el9_6/ef713ec3.failed

It constantly returns false since 2017.  One assertion is added in 2019 but
it should never have triggered, IOW it means what is checked should be
asserted instead.

If it didn't exist for 7 years maybe it's good idea to remove it and only
add it when it comes.

Link: https://lkml.kernel.org/r/20240826204353.2228736-3-peterx@redhat.com
	Signed-off-by: Peter Xu <peterx@redhat.com>
	Reviewed-by: Jason Gunthorpe <jgg@nvidia.com>
	Acked-by: David Hildenbrand <david@redhat.com>
	Cc: Matthew Wilcox <willy@infradead.org>
	Cc: Aneesh Kumar K.V <aneesh.kumar@linux.ibm.com>
	Cc: Alexander Gordeev <agordeev@linux.ibm.com>
	Cc: Alex Williamson <alex.williamson@redhat.com>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Catalin Marinas <catalin.marinas@arm.com>
	Cc: Christian Borntraeger <borntraeger@linux.ibm.com>
	Cc: Dave Hansen <dave.hansen@linux.intel.com>
	Cc: Gavin Shan <gshan@redhat.com>
	Cc: Gerald Schaefer <gerald.schaefer@linux.ibm.com>
	Cc: Heiko Carstens <hca@linux.ibm.com>
	Cc: Ingo Molnar <mingo@redhat.com>
	Cc: Niklas Schnelle <schnelle@linux.ibm.com>
	Cc: Paolo Bonzini <pbonzini@redhat.com>
	Cc: Ryan Roberts <ryan.roberts@arm.com>
	Cc: Sean Christopherson <seanjc@google.com>
	Cc: Sven Schnelle <svens@linux.ibm.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Vasily Gorbik <gor@linux.ibm.com>
	Cc: Will Deacon <will@kernel.org>
	Cc: Zi Yan <ziy@nvidia.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
(cherry picked from commit ef713ec3a566d3e5e011c5d6201eb661ebf94c1f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/huge_mm.h
#	mm/huge_memory.c
diff --cc include/linux/huge_mm.h
index fc789c0ac85b,ffca706bac81..000000000000
--- a/include/linux/huge_mm.h
+++ b/include/linux/huge_mm.h
@@@ -256,13 -433,8 +256,18 @@@ static inline bool is_huge_zero_pmd(pmd
  	return pmd_present(pmd) && READ_ONCE(huge_zero_pfn) == pmd_pfn(pmd);
  }
  
++<<<<<<< HEAD
 +static inline bool is_huge_zero_pud(pud_t pud)
 +{
 +	return false;
 +}
 +
 +struct page *mm_get_huge_zero_page(struct mm_struct *mm);
 +void mm_put_huge_zero_page(struct mm_struct *mm);
++=======
+ struct folio *mm_get_huge_zero_folio(struct mm_struct *mm);
+ void mm_put_huge_zero_folio(struct mm_struct *mm);
++>>>>>>> ef713ec3a566 (mm: drop is_huge_zero_pud())
  
  #define mk_huge_pmd(page, prot) pmd_mkhuge(mk_pmd(page, prot))
  
@@@ -379,12 -573,7 +384,16 @@@ static inline bool is_huge_zero_pmd(pmd
  	return false;
  }
  
++<<<<<<< HEAD
 +static inline bool is_huge_zero_pud(pud_t pud)
 +{
 +	return false;
 +}
 +
 +static inline void mm_put_huge_zero_page(struct mm_struct *mm)
++=======
+ static inline void mm_put_huge_zero_folio(struct mm_struct *mm)
++>>>>>>> ef713ec3a566 (mm: drop is_huge_zero_pud())
  {
  	return;
  }
diff --cc mm/huge_memory.c
index 20d9b3971dc8,a4a14b81e013..000000000000
--- a/mm/huge_memory.c
+++ b/mm/huge_memory.c
@@@ -1236,17 -1703,8 +1234,22 @@@ int copy_huge_pud(struct mm_struct *dst
  		goto out_unlock;
  
  	/*
++<<<<<<< HEAD
 +	 * When page table lock is held, the huge zero pud should not be
 +	 * under splitting since we don't split the page itself, only pud to
 +	 * a page table.
 +	 */
 +	if (is_huge_zero_pud(pud)) {
 +		/* No huge zero pud yet */
 +	}
 +
 +	/*
 +	 * TODO: once we support anonymous pages, use page_try_dup_anon_rmap()
 +	 * and split if duplicating fails.
++=======
+ 	 * TODO: once we support anonymous pages, use
+ 	 * folio_try_dup_anon_rmap_*() and split if duplicating fails.
++>>>>>>> ef713ec3a566 (mm: drop is_huge_zero_pud())
  	 */
  	pudp_set_wrprotect(src_mm, addr, src_pud);
  	pud = pud_mkold(pud_wrprotect(pud));
* Unmerged path include/linux/huge_mm.h
* Unmerged path mm/huge_memory.c
