mm: remove follow_pfn

jira LE-3557
Rebuild_History Non-Buildable kernel-5.14.0-570.26.1.el9_6
commit-author Christoph Hellwig <hch@lst.de>
commit cb10c28ac82c9b7a5e9b3b1dc7157036c20c36dd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-570.26.1.el9_6/cb10c28a.failed

Remove follow_pfn now that the last user is gone.

Link: https://lkml.kernel.org/r/20240324234542.2038726-3-hch@lst.de
	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: David Hildenbrand <david@redhat.com>
	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: Dave Hansen <dave.hansen@linux.intel.com>
	Cc: Fei Li <fei1.li@intel.com>
	Cc: Ingo Molnar <mingo@kernel.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Nathan Chancellor <nathan@kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
(cherry picked from commit cb10c28ac82c9b7a5e9b3b1dc7157036c20c36dd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/nommu.c
diff --cc mm/nommu.c
index f3f6a7e97647,331d2f778695..000000000000
--- a/mm/nommu.c
+++ b/mm/nommu.c
@@@ -110,29 -110,6 +110,32 @@@ unsigned int kobjsize(const void *objp
  	return page_size(page);
  }
  
++<<<<<<< HEAD
 +/**
 + * follow_pfn - look up PFN at a user virtual address
 + * @vma: memory mapping
 + * @address: user virtual address
 + * @pfn: location to store found PFN
 + *
 + * Only IO mappings and raw PFN mappings are allowed.
 + *
 + * Returns zero and the pfn at @pfn on success, -ve otherwise.
 + */
 +int follow_pfn(struct vm_area_struct *vma, unsigned long address,
 +	unsigned long *pfn)
 +{
 +	if (!(vma->vm_flags & (VM_IO | VM_PFNMAP)))
 +		return -EINVAL;
 +
 +	*pfn = address >> PAGE_SHIFT;
 +	return 0;
 +}
 +EXPORT_SYMBOL(follow_pfn);
 +
 +LIST_HEAD(vmap_area_list);
 +
++=======
++>>>>>>> cb10c28ac82c (mm: remove follow_pfn)
  void vfree(const void *addr)
  {
  	kfree(addr);
diff --git a/include/linux/mm.h b/include/linux/mm.h
index 196c481ec160..cd16e4cb2ce0 100644
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -2429,8 +2429,6 @@ int
 copy_page_range(struct vm_area_struct *dst_vma, struct vm_area_struct *src_vma);
 int follow_pte(struct mm_struct *mm, unsigned long address,
 	       pte_t **ptepp, spinlock_t **ptlp);
-int follow_pfn(struct vm_area_struct *vma, unsigned long address,
-	unsigned long *pfn);
 int follow_phys(struct vm_area_struct *vma, unsigned long address,
 		unsigned int flags, unsigned long *prot, resource_size_t *phys);
 int generic_access_phys(struct vm_area_struct *vma, unsigned long addr,
diff --git a/mm/memory.c b/mm/memory.c
index e2794e3b8919..4498a39fb51d 100644
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -5623,8 +5623,8 @@ int __pmd_alloc(struct mm_struct *mm, pud_t *pud, unsigned long address)
  * Only IO mappings and raw PFN mappings are allowed.  The mmap semaphore
  * should be taken for read.
  *
- * KVM uses this function.  While it is arguably less bad than ``follow_pfn``,
- * it is not a good general-purpose API.
+ * KVM uses this function.  While it is arguably less bad than the historic
+ * ``follow_pfn``, it is not a good general-purpose API.
  *
  * Return: zero on success, -ve otherwise.
  */
@@ -5666,38 +5666,6 @@ int follow_pte(struct mm_struct *mm, unsigned long address,
 }
 EXPORT_SYMBOL_GPL(follow_pte);
 
-/**
- * follow_pfn - look up PFN at a user virtual address
- * @vma: memory mapping
- * @address: user virtual address
- * @pfn: location to store found PFN
- *
- * Only IO mappings and raw PFN mappings are allowed.
- *
- * This function does not allow the caller to read the permissions
- * of the PTE.  Do not use it.
- *
- * Return: zero and the pfn at @pfn on success, -ve otherwise.
- */
-int follow_pfn(struct vm_area_struct *vma, unsigned long address,
-	unsigned long *pfn)
-{
-	int ret = -EINVAL;
-	spinlock_t *ptl;
-	pte_t *ptep;
-
-	if (!(vma->vm_flags & (VM_IO | VM_PFNMAP)))
-		return ret;
-
-	ret = follow_pte(vma->vm_mm, address, &ptep, &ptl);
-	if (ret)
-		return ret;
-	*pfn = pte_pfn(ptep_get(ptep));
-	pte_unmap_unlock(ptep, ptl);
-	return 0;
-}
-EXPORT_SYMBOL(follow_pfn);
-
 #ifdef CONFIG_HAVE_IOREMAP_PROT
 int follow_phys(struct vm_area_struct *vma,
 		unsigned long address, unsigned int flags,
* Unmerged path mm/nommu.c
