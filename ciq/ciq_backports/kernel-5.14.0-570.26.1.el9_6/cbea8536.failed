mm/x86/pat: use the new follow_pfnmap API

jira LE-3557
Rebuild_History Non-Buildable kernel-5.14.0-570.26.1.el9_6
commit-author Peter Xu <peterx@redhat.com>
commit cbea8536d933d546ceb1005bf9c04f9d01da8092
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-570.26.1.el9_6/cbea8536.failed

Use the new API that can understand huge pfn mappings.

Link: https://lkml.kernel.org/r/20240826204353.2228736-13-peterx@redhat.com
	Signed-off-by: Peter Xu <peterx@redhat.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Ingo Molnar <mingo@redhat.com>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Dave Hansen <dave.hansen@linux.intel.com>
	Cc: Alexander Gordeev <agordeev@linux.ibm.com>
	Cc: Alex Williamson <alex.williamson@redhat.com>
	Cc: Aneesh Kumar K.V <aneesh.kumar@linux.ibm.com>
	Cc: Catalin Marinas <catalin.marinas@arm.com>
	Cc: Christian Borntraeger <borntraeger@linux.ibm.com>
	Cc: David Hildenbrand <david@redhat.com>
	Cc: Gavin Shan <gshan@redhat.com>
	Cc: Gerald Schaefer <gerald.schaefer@linux.ibm.com>
	Cc: Heiko Carstens <hca@linux.ibm.com>
	Cc: Jason Gunthorpe <jgg@nvidia.com>
	Cc: Matthew Wilcox <willy@infradead.org>
	Cc: Niklas Schnelle <schnelle@linux.ibm.com>
	Cc: Paolo Bonzini <pbonzini@redhat.com>
	Cc: Ryan Roberts <ryan.roberts@arm.com>
	Cc: Sean Christopherson <seanjc@google.com>
	Cc: Sven Schnelle <svens@linux.ibm.com>
	Cc: Vasily Gorbik <gor@linux.ibm.com>
	Cc: Will Deacon <will@kernel.org>
	Cc: Zi Yan <ziy@nvidia.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
(cherry picked from commit cbea8536d933d546ceb1005bf9c04f9d01da8092)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/mm/pat/memtype.c
diff --cc arch/x86/mm/pat/memtype.c
index 36b603d0cdde,f73b5ce270b3..000000000000
--- a/arch/x86/mm/pat/memtype.c
+++ b/arch/x86/mm/pat/memtype.c
@@@ -947,6 -948,26 +947,29 @@@ static void free_pfn_range(u64 paddr, u
  		memtype_free(paddr, paddr + size);
  }
  
++<<<<<<< HEAD
++=======
+ static int follow_phys(struct vm_area_struct *vma, unsigned long *prot,
+ 		resource_size_t *phys)
+ {
+ 	struct follow_pfnmap_args args = { .vma = vma, .address = vma->vm_start };
+ 
+ 	if (follow_pfnmap_start(&args))
+ 		return -EINVAL;
+ 
+ 	/* Never return PFNs of anon folios in COW mappings. */
+ 	if (!args.special) {
+ 		follow_pfnmap_end(&args);
+ 		return -EINVAL;
+ 	}
+ 
+ 	*prot = pgprot_val(args.pgprot);
+ 	*phys = (resource_size_t)args.pfn << PAGE_SHIFT;
+ 	follow_pfnmap_end(&args);
+ 	return 0;
+ }
+ 
++>>>>>>> cbea8536d933 (mm/x86/pat: use the new follow_pfnmap API)
  static int get_pat_info(struct vm_area_struct *vma, resource_size_t *paddr,
  		pgprot_t *pgprot)
  {
* Unmerged path arch/x86/mm/pat/memtype.c
